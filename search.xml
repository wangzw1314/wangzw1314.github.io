<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker镜像管理]]></title>
    <url>%2F2018%2F12%2F19%2FDocker%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[一.关于Docker镜像 Docker镜像含有启动容器所需要的文件系统及其内容 ,因此 其用于创建并启动docke镜像. 采用分层构建机制 最底层为bootfs ,向上为rootfs bootfs:用于系统引导的文件系统,包括bootloader和kernel ,容器启动完成后会被卸载以节约内存资源 rootfs:位于bootfs之上,变现为docker容器的跟文件系统 - 传统模式中,系统启动之时,内核挂载tootfs时会首先将其挂载为&quot;只读&quot; 模式,完整性自检完成后将其重新挂载为读写模式 - docker中,rootfs由内核挂载为&quot;只读&quot;模式,而后通过&quot;联合挂载&quot;技术额外挂载一个&quot;可写&quot;层; 二.Docker镜像分层 位于下层的镜像称为父镜像,最底层的称为基础镜像(base image) 最上层为”可读写”层,其下的均为”只读”层 当删除容器时 ,可写层会一起删除 三.Docker存储 启动容器时,docker daemon会试图从本地获取相关的镜像,本地镜像不存在时,其将从Registry中下载该镜像并保存到本地. Registry没有特别指定 默认为docker hub ,如果使用别的Registry ,则必须在镜像的访问路径给名服务器地址 四.Docker Hub注册账号:https://hub.docker.com/signup 获取镜像: #docker pull &lt;registry&gt;[:&lt;port&gt;]/[&lt;namespace&gt;/]&lt;name&gt;:&lt;tag&gt; &lt;registry&gt;[:&lt;port&gt;] 哪个仓库服务器加端口 docker hub 可省略 /[&lt;namespace&gt;/] 名称空间 哪个用户的仓库 顶层可省略 &lt;name&gt;:&lt;tag&gt; 仓库名加标签名 其他著名仓库服务器:https://quay.io/例: [root@Docker ~]# docker pull quay.io/coreos/flannel:v0.10.0-s390x //端口默认为443 五.镜像相关操作5.1 镜像的生成途径 Dockerfile 基于容器制作 Docker Hub automater builds 5.2 基于容器做镜像1.先启动一个容器 做好修改先pull busybox镜像 启动后做一个主页 这样下次启动主页就存在 [root@liujie ~]# docker run --name web1 -it busybox / # mkdir /data/html mkdir: can&apos;t create directory &apos;/data/html&apos;: No such file or directory / # mkdir -p /data/html / # vi /data/html/index.html hello httpd //此时不能关闭容器 2.基于容器做镜像Usage: docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]docker commit [OPTIONS] CONTAINER 基于哪个容器做镜像[REPOSITORY[:TAG]] 属于哪个仓库拥有什么标签 如果省略则代表本地的裸镜像 不属于任何仓库 [root@liujie ~]# docker commit -p web1 //-p是暂停 防止保存部分文件 sha256:b4ecf4975f3b22284c26be372197aa73029d0781acaeb584456fb624fc1fa934 [root@liujie ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE &lt;none&gt; &lt;none&gt; b4ecf4975f3b 12 minutes ago 1.15MB 仓库为空 标签也为空 id为生成id 为了后续管理 可以为打标签 [root@liujie ~]# docker tag b4ecf4975f3b 18834478096/httpd:v0.1 //基于id 18834478096为docker hub账号为后续上传 [root@liujie ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE 18834478096/httpd v0.1 b4ecf4975f3b About an hour ago 1.15MB 删除镜像： 两个标签时可删除 只有一个标签删除会报错 [root@liujie ~]# docker image rm liujie/httpd:v0.1.1 Untagged: liujie/httpd:v0.1.1 3. 启动做好的镜像[root@liujie ~]# docker run --name t1 -it 18834478096/httpd:v0.1 / # cd / / # ls bin data dev etc home proc root sys tmp usr var / # //之前创建好的data目录存在 5.3 上传镜像放到docker hub上： 1.注册账号https://hub.docker.com/ 2.使用Docker hub账号在验证本地登录[root@liujie ~]# docker login -u 18834478096 Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded 3. 查看本地的镜像[root@liujie ~]# docker image images REPOSITORY TAG IMAGE ID CREATED SIZE 18834478096/httpd v0.1 b4ecf4975f3b 3 hours ago 1.15MB 如果REPOITORY的名不是你Docker hub账号和仓库，即Docker ID/仓库名，是上传不成功的 4.在Docker Hub上创建仓库 5.推镜像[root@liujie ~]# docker image push 18834478096/httpd:v0.1 The push refers to repository [docker.io/18834478096/httpd] de66091347b2: Pushed 8a788232037e: Mounted from library/busybox v0.1: digest: sha256:eccf03eea662b180d52d3c4909bcd82cfc7a7b319c6a4d664643750cdf0544b9 size: 734 上传阿里镜像仓库 https://cr.console.aliyun.com/ 选择本地仓库 创建镜像仓库 点击管理 1.给镜像打标签 使用阿里云地址 [root@liujie ~]# docker image images REPOSITORY TAG IMAGE ID CREATED SIZE 18834478096/httpd v0.1 b4ecf4975f3b 3 hours ago 1.15MB [root@liujie ~]# docker tag 18834478096/httpd:v0.1 registry.cn-qingdao.aliyuncs.com/18834478096/httpd:v0.1 [root@liujie ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE 18834478096/httpd v0.1 b4ecf4975f3b 3 hours ago 1.15MB registry.cn-qingdao.aliyuncs.com/18834478096/httpd v0.1 b4ecf4975f3b 3 hours ago 1.15MB 2.登录阿里云 [root@liujie ~]# docker logout Removing login credentials for https://index.docker.io/v1/ [root@liujie ~]# docker login --username=18834478096 registry.cn-qingdao.aliyuncs.com Password: //密码为Registry登录密码 WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded 3.推镜像 [root@liujie ~]# docker push registry.cn-qingdao.aliyuncs.com/18834478096/httpd:v0.1 The push refers to repository [registry.cn-qingdao.aliyuncs.com/18834478096/httpd] de66091347b2: Pushed 8a788232037e: Pushed v0.1: digest: sha256:eccf03eea662b180d52d3c4909bcd82cfc7a7b319c6a4d664643750cdf0544b9 size: 734 5.4 镜像导入导出打包镜像 [root@liujie ~]# docker save -o myfirst.gz 18834478096/httpd:v0.1 [root@liujie ~]# ll total 230540 -rw------- 1 root root 1386496 Dec 19 23:01 myfirst.gz 发送压缩包到其他docker主机使用 [root@liujie2 ~]# docker load -i myfirst.gz [root@liujie2 ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE 18834478096/httpd v0.1 b4ecf4975f3b 4 hours ago 1.15MB 这种方法run之前要先pull镜像 不然run还会从默认地址下镜像]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Docker基础用法]]></title>
    <url>%2F2018%2F12%2F19%2FDocker%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Docker私有registry Harbor]]></title>
    <url>%2F2018%2F12%2F19%2FDocker%E7%A7%81%E6%9C%89registry%20Harbor%2F</url>
    <content type="text"><![CDATA[一. Harbor 简介 Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器，通过添加一些企业必需的功能特性，例如安全、标识和管理等，扩展了开源Docker Distribution。作为一个企业级私有Registry服务器，Harbor提供了更好的性能和安全。提升用户使用Registry构建和运行环境传输镜像的效率。Harbor支持安装在多个Registry节点的镜像资源复制，镜像全部保存在私有Registry中， 确保数据和知识产权在公司内部网络中管控。另外，Harbor也提供了高级的安全特性，诸如用户管理，访问控制和活动审计等。 1.1 Harbor组件 Proxy：Harbor的registry, UI, token等服务，通过一个前置的反向代理统一接收浏览器、Docker客户端的请求，并将请求转发给后端不同的服务。 Registry： 负责储存Docker镜像，并处理docker push/pull 命令。由于我们要对用户进行访问控制，即不同用户对Docker image有不同的读写权限，Registry会指向一个token服务，强制用户的每次docker pull/push请求都要携带一个合法的token, Registry会通过公钥对token 进行解密验证。 Core services： 这是Harbor的核心功能，主要提供以下服务： UI：提供图形化界面，帮助用户管理registry上的镜像（image）, 并对用户进行授权。 webhook：为了及时获取registry 上image状态变化的情况， 在Registry上配置webhook，把状态变化传递给UI模块。 token 服务：负责根据用户权限给每个docker push/pull命令签发token. Docker 客户端向Regiøstry服务发起的请求,如果不包含token，会被重定向到这里，获得token后再重新向Registry进行请求。 Database：为core services提供数据库服务，负责储存用户权限、审计日志、Docker image分组信息等数据。 Job Services：提供镜像远程复制功能，可以把本地镜像同步到其他Harbor实例中。 Log collector：为了帮助监控Harbor运行，负责收集其他组件的log，供日后进行分析。 Volnerability Scanning：对应启动组件clair。负责镜像扫描 Notary：对应启动组件notary。负责镜像认证 DB：对应启动组件harbor-db，负责存储project、 user、 role、replication、image_scan、access等的metadata数据。 1.2 Harbor实现Harbor的每个组件都是以Docker容器的形式构建的，官方也是使用Docker Compose来对它进行部署。用于部署Harbor的Docker Compose模板位于 harbor/docker-compose.yml,打开这个模板文件，发现Harbor是由7个容器组成的； [root@aliyun harbor]# cd /usr/local/harbor/ //解压路径 [root@aliyun harbor]# docker-compose ps Name Command State Ports ------------------------------------------------------------------------------------------------------------------------------ harbor-adminserver /harbor/harbor_adminserver Up harbor-db docker-entrypoint.sh mysqld Up 3306/tcp harbor-jobservice /harbor/harbor_jobservice Up harbor-log /bin/sh -c crond &amp;&amp; rm -f ... Up 127.0.0.1:1514-&gt;514/tcp harbor-ui /harbor/harbor_ui Up nginx nginx -g daemon off; Up 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:4443-&gt;4443/tcp, 0.0.0.0:80-&gt;80/tcp registry /entrypoint.sh serve /etc/ ... Up 5000/tcp nginx：nginx负责流量转发和安全验证，对外提供的流量都是从nginx中转，所以开放https的443端口，它将流量分发到后端的ui和正在docker镜像存储的docker registry。 harbor-jobservice：harbor-jobservice 是harbor的job管理模块，job在harbor里面主要是为了镜像仓库之前同步使用的; harbor-ui：harbor-ui是web管理页面，主要是前端的页面和后端CURD的接口; registry：registry就是docker原生的仓库，负责保存镜像。 harbor-adminserver：harbor-adminserver是harbor系统管理接口，可以修改系统配置以及获取系统信息。 这几个容器通过Docker link的形式连接在一起，在容器之间通过容器名字互相访问。对终端用户而言，只需要暴露proxy （即Nginx）的服务端口。 harbor-db：harbor-db是harbor的数据库，这里保存了系统的job以及项目、人员权限管理。由于本harbor的认证也是通过数据，在生产环节大多对接到企业的ldap中； harbor-log：harbor-log是harbor的日志服务，统一管理harbor的日志。通过inspect可以看出容器统一将日志输出的syslog。 这几个容器通过Docker link的形式连接在一起，这样，在容器之间可以通过容器名字互相访问。对终端用户而言，只需要暴露proxy （即Nginx）的服务端口。 二.安装Harbor2.1 安装准备：Harbor 托管在github上 https://github.com/vmware/harbor安装配置说明 :https://github.com/goharbor/harbor/blob/master/docs/installation_guide.md版本：https://github.com/goharbor/harbor/releases 安装有两种方式，一种是off-line ，一种是on-line，即离线和在线安装，离线安装需要下载的安装包较大，在线安装下载的安装包很小安装前需要安装docker 和 docker-compose 2.2 安装Harbor 下载离线安装包 [root@aliyun ~]# wget https://storage.googleapis.com/harbor-releases/harbor-offline-installer-v1.5.2.tgz 解压 [root@aliyun ~]# tar xf harbor-offline-installer-v1.5.2.tgz -C /usr/local/ 修改配置文件 # vim /usr/local/harbor/harbor.cfg hostname = 192.168.10.1 //服务器地址 #邮箱配置 email_server = smtp.qq.com email_server_port = 25 email_username = unixfbi@unixfbi.com email_password =12345678 email_from = UnixFBI &lt;unixfbi@unixfbi.com&gt; email_ssl = false #禁止用户注册 self_registration = off #设置只有管理员可以创建项目 project_creation_restriction = adminonly 执行安装脚本 # /usr/local/harbor/install.sh Harbor的启动与停止 Harbor 的日常运维管理是通过docker-compose来完成的，Harbor本身有多个服务进程，都放在docker容器之中运行，我们可以通过 docker-compose 来查看 [root@aliyun harbor]# cd /usr/local/harbor/ //解压路径 [root@aliyun harbor]# docker-compose ps Name Command State Ports ------------------------------------------------------------------------------------------------------------------------------ harbor-adminserver /harbor/harbor_adminserver Up harbor-db docker-entrypoint.sh mysqld Up 3306/tcp harbor-jobservice /harbor/harbor_jobservice Up harbor-log /bin/sh -c crond &amp;&amp; rm -f ... Up 127.0.0.1:1514-&gt;514/tcp harbor-ui /harbor/harbor_ui Up nginx nginx -g daemon off; Up 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:4443-&gt;4443/tcp, 0.0.0.0:80-&gt;80/tcp registry /entrypoint.sh serve /etc/ ... Up 5000/tcp Harbor的启动和停止 启动Harbor # docker-compose start 停止Harbor # docker-comose stop 重启Harbor # docker-compose restart 访问测试 浏览器访问 192.168.10.1默认账号密码： admin / Harbor12345 登录后修改密码]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Docker简介]]></title>
    <url>%2F2018%2F12%2F19%2FDocker%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。 CentOS 7 安装Docker CE 一.安装准备系统要求Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。 卸载旧版本旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本： yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine 二.使用yum安装2.1使用清华大学的镜像站 [root@liujie yum.repos.d]# wget https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo 替换url： [root@liujie yum.repos.d]# vim docker-ce.repo :%s@https://download.docker.com/@https://mirrors.tuna.tsinghua.edu.cn/docker-ce/@ 2.2安装Docker[root@liujie yum.repos.d]# yum install docker-ce -y 解决 docker-ce 安装报错 cont9ainer-selinux &gt;= 2.9 1. 下载container-selinux-2.9-4下载地址： ftp://ftp.icm.edu.pl/vol/rzm3/linux-centos-vault/7.3.1611/extras/x86_64/Packages/container-selinux-2.9-4.el7.noarch.rpm 2.安装 container-selinux[root@liujie yum.repos.d]# yum install container-selinux-2.9-4.el7.noarch.rpm 2.3 镜像加速器阿里云镜像加速器：https://cr.console.aliyun.com/#/accelerator使用配置文件/etc/docker/daemon.json（没有时新建该文件）。 { &quot;registry-mirrors&quot;: [&quot;https://q95dlt3p.mirror.aliyuncs.com&quot;] } 注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。 启动docker [root@liujie ~]# systemctl restart docker [root@liujie ~]# docker version Client: Version: 18.09.0 API version: 1.39 Go version: go1.10.4 Git commit: 4d60db4 Built: Wed Nov 7 00:48:22 2018 OS/Arch: linux/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 18.09.0 API version: 1.39 (minimum version 1.12) Go version: go1.10.4 Git commit: 4d60db4 Built: Wed Nov 7 00:19:08 2018 OS/Arch: linux/amd64 Experimental: false 三.常用操作docker [OPTIONS] COMMANDCOMMAND 又为子命令 分为几类建议使用分组的管理命令 3.1 #docker info查看docker系统信息。 [root@liujie ~]# docker info Containers: 0 //显示容器个数 Running: 0 //运行状态的 Paused: 0 //暂停状态的 Stopped: 0 //停止状态的 Images: 3 //有多少个镜像 Server Version: 18.09.0 Storage Driver: overlay2 //存储驱动后端 Backing Filesystem: xfs Supports d_type: true Native Overlay Diff: true Logging Driver: json-file Cgroup Driver: cgroupfs Plugins: Volume: local Network: bridge host macvlan null overlay Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog Swarm: inactive .......... Insecure Registries: 127.0.0.0/8 Registry Mirrors: https://q95dlt3p.mirror.aliyuncs.com/ //阿里云加速 Live Restore Enabled: false Product License: Community Engine 3.2 #docker search搜索镜像 –automated :只列出 automated build类型的镜像； –no-trunc :显示完整的镜像描述； -s :列出收藏数不小于指定值的镜像。 [root@liujie ~]# docker search -s 200 redis Flag --stars has been deprecated, use --filter=stars=3 instead NAME DESCRIPTION STARS OFFICIAL AUTOMATED redis Redis is an open source key-value store that… 6299 [OK] 3.3 #docker image pull从镜像仓库中拉取或者更新指定镜像 [root@liujie ~]# docker image pull nginx:1.14-alpine 3.4 #docker images列出本地所以镜像-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；–digests :显示镜像的摘要信息；-f :显示满足条件的镜像；–format :指定返回值的模板文件；–no-trunc :显示完整的镜像信息；-q :只显示镜像ID [root@liujie ~]# docker image images nginx REPOSITORY TAG IMAGE ID CREATED SIZE nginx 1.14-alpine d956af1ad36a 13 days ago 17.7MB nginx latest 568c4670fa80 3 weeks ago 109MB 3.5 #docker image rm 或者docker rmi删除docker镜像而docker rm 则为删除容器 [root@liujie ~]# docker image rm redis 3.6 #docker container create创建容器 3.7 # docker container ls 或 # docker ps列出容器 3.8 # docker container run创建并运行容器 root@liujie ~]# docker container run --name b1 -it busybox 3.9 # docker container stop停止容器 [root@liujie ~]# docker container stop b2 b2 3.10 #docker container rm删除容器删除容器先停止容器 [root@liujie ~]# docker container rm b1 b1 3.11 #docker container logs获取容器的日志 [root@liujie ~]# docker container logs web1 172.17.0.1 - - [19/Dec/2018:07:33:38 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.29.0&quot; &quot;-&quot;]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Nginx的https服务]]></title>
    <url>%2F2018%2F12%2F16%2FNginx%E7%9A%84https%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[一.HTTPS 1.传输数据被中间人盗用，信息泄露 2.数据内容劫持，篡改 https协议实现： 对传输内容进行加密以及身份验证 二，签名证书生成2.1 确保安装了openssl[root@liujie ~]# openssl version OpenSSL 1.0.2k-fips 26 Jan 2017 2.2 生成key文件[root@liujie ~]# cd /etc/nginx/ [root@liujie nginx]# mkdir ssl_key [root@liujie nginx]# cd ssl_key/ [root@liujie ssl_key]# openssl genrsa -idea -out jesonc.key 1024 然后输入密码 [root@liujie ssl_key]# ll total 0 -rw-r--r-- 1 root root 0 Dec 16 03:09 jesonc.key 2.3创建签名请求的证书（CSR）[root@liujie ssl_key]# openssl req -new -key jesonc.key -out jesonc.csr //输入密码 If you enter &apos;.&apos;, the field will be left blank. ----- Country Name (2 letter code) [XX]:CN //国家 State or Province Name (full name) []:beijing //省 Locality Name (eg, city) [Default City]:beijing //市 Organization Name (eg, company) [Default Company Ltd]:CN Organizational Unit Name (eg, section) []:liujie //部门 Common Name (eg, your name or your server&apos;s hostname) []:liujie.com //授权（证书）网址 Email Address []:liujie961010@163.com //邮箱 Please enter the following &apos;extra&apos; attributes to be sent with your certificate request A challenge password []: //密码 妥善保管 An optional company name []:gongsimingzi //公司名字 可不填 2.4 根据两文件建立字签名crt证书[root@liujie ssl_key]# openssl x509 -req -days 3650 -in jesonc..csr -signkey jesonc..key -out jesonc.crt //3650代表证书过期时间 //输入密码 2.5 nginx的https服务器配置虚拟server [root@liujie conf.d]# vim test_https.conf server { listen 443; server_name 10.10.11.221 liujie.com; ssl on; ssl_certificate /etc/nginx/ssl_key/jesonc.crt; ssl_certificate_key /etc/nginx/ssl_key/jesonc.key; #ssl_certificate_key /etc/nginx/ssl_key/jesonc_nopass.key; index index.html index.htm; location / { root /opt/app/code; } } 重启nginx 查看端口： [root@liujie run]# netstat -luntp | grep 443 tcp 0 0 0.0.0.0:443 0.0.0.0:* LISTEN 2356/nginx: master 如果出现：nginx: [error] invalid PID number “” in “/run/nginx.pid”则：需要先执行 nginx -c /etc/nginx/nginx.conf nginx -s reload 2.6 访问测试 三.https优化 1.激活keeplive长连接 2.设置ssl session缓存 server { listen 443; server_name 10.10.11.221 liujie.com; keepalive_timeout 100; //nginx长连接——keepalive 默认为75s ssl on; ssl_session_cache shared:SSL:10m; //共享缓存 10m可存储8000-10000的session会话 ssl_session_timeout 10m; //10分钟session过期 ssl_certificate /etc/nginx/ssl_key/jesonc.crt; ssl_certificate_key /etc/nginx/ssl_key/jesonc.key; #ssl_certificate_key /etc/nginx/ssl_key/jesonc_nopass.key; index index.html index.htm; location / { root /opt/app/code; } }]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LVS集群-NAT模式]]></title>
    <url>%2F2018%2F12%2F16%2FLVS%E9%9B%86%E7%BE%A4-NAT%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一.集群概述 一组各自相互独立且又相互依赖的,通过高速网络互联的计算机组成的一个计算机组, 以单一的系统模式加以管理, 为用户提供服务, 对用户来说, 用户只会认为对方是一个服务. 这个里面, 一组计算机的一台计算机就是集群的一个节点 1.1 集群的种类：集群系统主要分为 负载均衡(Load Balance)集群，简称LB 高可用(High Availability)集群，简称 HA 集群 高性能计算(High Perfermance Computing)集群，简称 HPC 集群 1.2 LB实现手段硬件的实现： – F5 负载均衡器软件的实现： – LVS(4层，传输层) – Nginx(7层，应用层) 二. LVS集群LVS是Linux Virtual Server的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统。本项目在1998年5月由章文嵩博士成立，是中国国内最早出现的自由软件项目之一，是根据iptables的实现来开发的，所以使用时候会和iptables相当类似官网： http://www.linuxvirtualserver.org/ 中文站点： http://zh.linuxvirtualserver.org/ LVS 集群工作结构图： 负载调度器,：分发器(Load Balancer, Director): 整个集群对外的最前端机, 负责接收用户请求, 并且根据自己的调度算法, 将请求转发到后端真实服务器上的动作，而客户认为服务是来自一个IP地址（我们可称之为VIP虚拟IP地址）上的。 服务器池: Server Pool 真正为用户提供服务的服务器, 每一台服务器就是一台RS[RealServer]，执行的服务有WEB、MAIL、FTP和DNS等。 共享存储: Shared Storaged 为RS保持相同内容, 提供数据的一致性，也就是说，它为服务器池提供一个共享的存储区，这样很容易使得服务器池拥有相同的内容，提供相同的服务。 2.1 LVS模式及工作原理LVS(4层) 模式： LVS/NAT LVS-VS/DR LVS/TUN LVS负载均衡的三种包转发方式:LVS提供了三种包转发方式：NAT(网络地址映射)、IP Tunneling(IP隧道)、Direct Routing(直接路由)。不同的转发模式决定了不同的cluster的网络结构 NAT(网络地址映射) NAT: 网络地址转换DNAT: 目标地址转换 改变的是目标地址SNAT: 原地址转换 改变的是原地址LVS-NAT 就是使用的SNAT和DNAT完成报的转发NAT方式可支持任何的操作系统，以及私有网络，并且只需一个Internet IP地址，但是整个系统的性能受到限制。因为执行NAT每次需要重写包，有一定的延迟；另外，大部分应用有80%的数据是从服务器流向客户机，也就是用户的请求非常短，而服务器的回应非常大，对负载均衡器形成很大压力，成为了新的瓶颈。 IP Tunneling(IP隧道) director（分发器）分配请求到不同的real server。real server处理请求后直接回应给用户，这样director负载均衡器仅处理客户机与服务器的一半连接。IP Tunneling技术极大地提高了director的调度处理能力，同时也极大地提高了系统能容纳的最大节点数，可以超过100个节点。real server可以在任何LAN或WAN上运行，这意味着允许地理上的分布，这在灾难恢复中有重要意义。服务器必须拥有正式的IP地址用于与客户机直接通信，并且所有服务器必须支持IP隧道协议。 Direct Routing(直接路由) 与IP Tunneling类似，负载均衡器仅处理一半的连接，避免了新的性能瓶颈，同样增加了系统的可伸缩性。Direct Routing与IP Tunneling相比，没有IP封装的开销，但由于采用物理层（修改MAC地址）技术，所有服务器都必须在一个物理网段。 2.2 LVS-NAT 模式工作原理： 客户端访问调度器时，调度器通过网络地址转换，调度器重写请求报文的目标地址，根据预设的调度算法，将请求分派给后端的真实服务器；真实服务器的响应报文通过调度器时，报文的源地址被重写，再返回给客户，完成整个负载调度过程。 三.配置LVS-NAT 配置LVS： xuegod63配置成分发器： 1、打开路由转发功能 [root@xuegod63 ~]# vim /etc/sysctl.conf 改：net.ipv4.ip_forward = 0 为：net.ipv4.ip_forward = 1 让配置生效： [root@xuegod63 ~]# sysctl -p 2、配置网络环境：添加一个网卡（需要两张网卡）， 配置成以下网络环境：eth0 192.168.1.63 模式：br0 模拟公网eth1 192.168.2.63 模式：vmnet4 模拟内网 3 安装: LVS管理工具： ipvsadmin [root@xuegod63 Packages]# pwd /mnt/Packages [root@xuegod63 Packages]# rpm -ivh ipvsadm-1.25-9.el6.x86_64.rpm 或： yum install ipvsadm 4 使用ipvsadm命令设置规则： [root@xuegod63 ~]# ipvsadm -A -t 192.168.1.63:80 -s rr rr代表轮循 选项： -A 添加虚拟服务器 -t 表示TCP的服务 VIP：PORT -s 指定调度算法 rr表示round-robin 轮循 [root@xuegod63 ~]# ipvsadm -a -t 192.168.1.63:80 -r 192.168.2.64 -m [root@xuegod63 ~]# ipvsadm -a -t 192.168.1.63:80 -r 192.168.2.62 -m 选项： -a 表示添加real server的地址 -r 指定real server的IP地址 -m 表示masquerade 也就是NAT方式的LVS 5 查看：Ipvsadm命令，用于配置及查看内核IPVS表和算法的工具，类似于iptables [root@xuegod63 ~]# ipvsadm -L -n IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConn TCP 192.168.1.63:80 rr -&gt; 192.168.2.62:80 Masq 1 0 0 -&gt; 192.168.2.64:80 Masq 1 0 0 6 保存配置或规则 [root@xuegod63 ~]# ipvsadm --save &gt; /etc/sysconfig/ipvsadm 或ipvsadm -S 保存以上的配置 Saving IPVS table to /etc/sysconfig/ipvsadm: [确定] 7 配置真实服务器 RealServer：在xuegod62和xuegod64上面配置： 1、配置IP：REAL SERVER自己的网络相关信息配置成如下：xuegod62： eth0： vmnet4 ： 192.168.2.62 网关： 192.168.2.63xuegod64： eth0： vmnet4 ： 192.168.2.64 网关： 192.168.2.63 8 配置xuegod64为realserver， 并启web服务 [root@xuegod64 ~]# yum install -y httpd [root@xuegod64 ~]# systemctl restart httpd [root@xuegod64 ~]# echo &quot;192.168.2.64&quot; &gt; /var/www/html/index.html #（实验期间，各个服务器的页面不同） 9 配置xuegod62为realserver， 并启web服务 [root@xuegod62 ~]# yum install -y httpd [root@xuegod62 ~]# systemctl restart httpd [root@xuegod62 ~]# echo &quot;192.168.2.62&quot; &gt; /var/www/html/index.html #（实验期间，各个服务器的页面不同） 10 测试VIP： [root@xuegod63 ~]# elinks 192.168.1.63 –dump 192.168.2.62 [root@xuegod63 ~]# elinks 192.168.1.63 –dump 192.168.2.64 访问： 在物理上打开浏览器访问： 每按F5刷新一次，就会变换一个页面。 11 扩展ipvsadm 更多参数说明 -L -n ==&gt; 查看规则，显示内核虚拟服务器表 -L -n -c ==&gt; 查看客户端连接分发器和real server 的情况 例： [root@xuegod63 ~]# ipvsadm -L -n -c IPVS connection entries pro expire state source virtual destination TCP 01:33 TIME_WAIT 192.168.1.100:49698 192.168.1.70:80 192.168.2.62:80 TCP 01:26 TIME_WAIT 192.168.1.100:49690 192.168.1.70:80 192.168.2.64:80 TCP 01:57 TIME_WAIT 192.168.1.100:49739 192.168.1.70:80 192.168.2.62:80 选项： -L -n --stats ==&gt; 查看分发情况 -L -n --rate ==&gt; 查看速率 -Z --zero 虚拟服务表计数器清零（清空当前的连接数量等） [root@xuegod63 ~]# ipvsadm -Z [root@xuegod63 ~]# ipvsadm -L -n --stats IP Virtual Server version 1.2.1 (size=4096) 选项： -Z --clear 清空IPVS的数据、等信息 [root@xuegod63 ~]# ipvsadm -C 选项： -C 清空所有规则 LVS的规则配置文件：/etc/sysconfig/ipvsadm 12 ipvsadm命令选项解释-A –add-service 在内核的虚拟服务器表中添加一条新的虚拟服务器记录。也就是增加一台新的虚拟服务器。-E –edit-service 编辑内核虚拟服务器表中的一条虚拟服务器记录。-D –delete-service 删除内核虚拟服务器表中的一条虚拟服务器记录。-C –clear 清除内核虚拟服务器表中的所有记录。-R –restore 恢复虚拟服务器规则-S –save 保存虚拟服务器规则，输出为-R 选项可读的格式-a –add-server 在内核虚拟服务器表的一条记录里添加一条新的真实服务器记录。也就是在一个虚拟服务器中增加一台新的真实服务器-e –edit-server 编辑一条虚拟服务器记录中的某条真实服务器记录-d –delete-server 删除一条虚拟服务器记录中的某条真实服务器记录-L|-l –list 显示内核虚拟服务器表-Z –zero 虚拟服务表计数器清零（清空当前的连接数量等）–set tcp tcpfin udp 设置连接超时值–start-daemon 启动同步守护进程。他后面可以是master 或backup，用来说明LVS Router 是master 或是backup。在这个功能上也可以采用keepalived的VRRP 功能。–stop-daemon 停止同步守护进程-h –help 显示帮助信息其他的选项:-t –tcp-service service-address 说明虚拟服务器提供的是tcp 的服务[vip:port] or [real-server-ip:port]-u –udp-service service-address 说明虚拟服务器提供的是udp 的服务[vip:port] or [real-server-ip:port]-f –fwmark-service fwmark 说明是经过iptables 标记过的服务类型。-s –scheduler scheduler 使用的调度算法，有这样几个选项rr|wrr|lc|wlc|lblc|lblcr|dh|sh|sed|nq,默认的调度算法是： wlc.-p –persistent [timeout] 持久稳固的服务。这个选项的意思是来自同一个客户的多次请求，将被同一台真实的服务器处理。timeout 的默认值为300 秒。-M –netmask netmask persistent granularity mask-r –real-server server-address 真实的服务器[Real-Server:port]-g –gatewaying 指定LVS 的工作模式为直接路由模式（也是LVS 默认的模式）-i –ipip 指定LVS 的工作模式为隧道模式-m –masquerading 指定LVS 的工作模式为NAT 模式-w –weight weight 真实服务器的权值–mcast-interface interface 指定组播的同步接口-c –connection 显示LVS 目前的连接 如：ipvsadm -L -c–timeout 显示tcp tcpfin udp 的timeout 值 如：ipvsadm -L –timeout–daemon 显示同步守护进程状态–stats 显示统计信息–rate 显示速率信息–sort 对虚拟服务器和真实服务器排序输出–numeric -n 输出IP 地址和端口的数字形式 超时时间用ipvsadm –set tcp tcpfin udp设置，比如 ipvsadm --set 120 20 100 表示tcp空闲等待时间为120 秒 客户端关闭链接等待时间为20秒 udp空闲等待为100秒]]></content>
      <categories>
        <category>负载与集群</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Nginx动静分离]]></title>
    <url>%2F2018%2F12%2F16%2FNginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[一.动静分离通过中间件将动态请求和静态请求分离&gt;&gt;减少不必要的请求消耗，减少请求延时。 ‘ 二.配置动静分离2.1nginx服务器 redhat7 Nginx 10.10.11.221 tomcat服务器 redhat7 tomcat+jdk 10.10.11.19 2.2 准备测试文件A：[root@liujie code]# vim /opt/app/code/test_mysite.html &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;测试ajax和跨域访问&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function(){ $.ajax({ //ajax调用 进行动态请求 type: &quot;GET&quot;, url: &quot;http://liujie.com/java_test.jsp&quot;, success: function(data) { $(&quot;#get_data&quot;).html(data) }, error: function() { alert(&quot;fail!!!,请刷新再试!&quot;); } }); }); &lt;/script&gt; &lt;body&gt; &lt;h1&gt;测试动静分离&lt;/h1&gt; &lt;img src=&quot;http://liujie.com/img/nginx.png&quot;/&gt; //请求一张静态图片 &lt;div id=&quot;get_data&quot;&gt;&lt;div&gt; &lt;/body&gt; &lt;/html&gt; B：为nginx静态请求准备图片[root@liujie code]# cd /opt/app/code/img/ [root@liujie img]# ll total 4 -rw-r--r-- 1 root root 2103 Aug 8 2017 nginx.png C:准备tomcat的动态页面[root@tomcat ROOT]# cd /usr/local/tomcat/webapps/ROOT/ [root@tomcat ROOT]# ll total 192 -rw-r----- 1 root root 27235 Nov 3 13:42 asf-logo-wide.svg -rw-r----- 1 root root 713 Nov 3 13:39 bg-button.png -rw-r----- 1 root root 1918 Nov 3 13:39 bg-middle.png -rw-r----- 1 root root 1392 Nov 3 13:39 bg-nav-item.png -rw-r----- 1 root root 1401 Nov 3 13:39 bg-nav.png -rw-r----- 1 root root 3103 Nov 3 13:39 bg-upper.png -rw-r----- 1 root root 21630 Nov 3 13:39 favicon.ico -rw-r----- 1 root root 12290 Nov 3 13:42 index.jsp -rw-r--r-- 1 root root 343 Aug 8 2017 java_test.jsp //动态页面 -rw-r----- 1 root root 7142 Nov 3 13:42 RELEASE-NOTES.txt -rw-r----- 1 root root 5581 Nov 3 13:42 tomcat.css -rw-r----- 1 root root 2066 Nov 3 13:39 tomcat.gif vim java_test.jsp //用于生成动态数字 &lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot;%&gt; &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;JSP Test Page&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;% Random rand = new Random(); out.println(&quot;&lt;h1&gt;Random number:&lt;/h1&gt;&quot;); out.println(rand.nextInt(99)+100); %&gt; &lt;/BODY&gt; &lt;/HTML&gt; 2.3 新建nginx下虚拟server[root@liujie code]# vim /etc/nginx/conf.d/test_mysite.conf upstream java_api{ server 10.10.11.19:8080; // 转发的服务器，upstream 为负载均衡做准备 } server { listen 80; server_name liujie.com; #charset koi8-r; access_log /var/log/nginx/log/host.access.log main; root /opt/app/code; // 静态资源存放目录 location ~ .*.jsp$ { proxy_pass http://java_api; // 动态请求的转发 proxy_set_header Host $host; #index index.html index.htm; } location ~ \.(jpg|png|gif)$ { // 静态请求直接读取 expires 1h; gzip on; } location /{ index index.html index.htm; } error_page 500 502 503 504 404 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } 三.测试页面重启nginx tomcat 3.1 需要配置谷歌浏览器，使浏览器支持跨域首先需要关闭谷歌浏览器的所有窗口右击谷歌浏览器图标——&gt;属性。弹出属性对话框。在目标栏最后添加 –args –disable-web-security –user-data-dir 注意空格 再次打开谷歌会提示： 3.2访问页面：刷新数字会变 则请求到了tomcat停止tomcat：静态页面正常展示]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Nginx作为缓存服务]]></title>
    <url>%2F2018%2F12%2F16%2FNginx%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[缓存类型客户端缓存，代理缓存(Nginx)，服务端缓存(Redis). nginx作为代理缓存proxy_ cache配置语法: Syntax: proxy_ cache_ path path [levels=levels] 定义目录的空间大小以及名字 用来防止缓存文件的 ……………….. Default:—— Context :http Syntax : proxy_ cache zone|off;Default: proxy_cache off;Context:http,server,location; 配置语法-缓存过期周期Syntax:proxy_ cache_ valid[code…] time; code代表状态码 200Default : ——Context : http,server,location 配置语法-缓存的维度 Synatx:proxy_ cache_ key string; Default : proxy_ cache_ key $scheme $proxy_ host $request_ uri; 缓存的key Context :http , server,location 配置vim /etc/nginx/cond.f/test.conf upstream imooc { //负载均衡服务器 server 192.168.1.111; server 192.168.1.222; server 192.168.1.333; } proxy_cache_path /opt/app/cache levels=1:2 keys_zone=cache:10m max_size=10g inactive=60m use_temp_path=off; proxy_cache_path /opt/app/cache 缓存文件的存放位置 levels=1:2 两层目录的分级 keys_zone=fan_cache:10m 开辟的空间大小 max_size=10g 最大空间 inactive=60m 不活跃的缓存文件。60分钟之后清理掉 use_temp_path=off 临时访问空间关掉 server { listen 80; server_name localhost; #charset koi8-r; access_log /var/log/nginx/test_proxy.access.log main; location / { proxy_cache cache; proxy_pass http://imooc; //基于代理 proxy_cache_valid 200 304 12h; proxy_cache_valid any 10m; proxy_cache_key $host$uri$is_args$args; add_header Nginx-Cache &quot;$upstream_cache_status&quot;; proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504; include proxy_params; proxy_cache cache; 上面定义的zone proxy_pass http://imooc; 定义的upstream proxy_cache_valid 200 304 12h; 为200和304的过期时间为12小时 proxy_cache_valid any 10m; 其他为10分钟 proxy_cache_key $host$uri$is_args$args; 缓存的key add_header Nginx-Cache &quot;$upstream_cache_status&quot;; 给客户端增加名为一个Nginx-Cache 的头信息 proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504; 如果服务器出现了定义的错误，跳过本节点访问下一台。 }]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[fail2ban的使用以及防暴力破解与邮件预警]]></title>
    <url>%2F2018%2F11%2F16%2Ffail2ban%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%98%B2%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E4%B8%8E%E9%82%AE%E4%BB%B6%E9%A2%84%E8%AD%A6%2F</url>
    <content type="text"><![CDATA[通过开源的防护软件来防护安全 使用背景：最近公网网站一直被别人暴力破解sshd服务密码。虽然没有成功，但会导致系统负载很高，原因是在暴力破解的时候，系统会不断地认证用户，从而增加了系统资源额外开销，导致访问公司网站速度很慢。 fail2ban可以监视你的系统日志，然后匹配日志的错误信息（正则式匹配）执行相应的屏蔽动作（一般情况下是防火墙），而且可以发送e-mail通知系统管理员，很好、很实用、很强大！ ban （bæn）禁令简单来说其功能就是防止暴力破解。工作的原理是通过分析一定时间内的相关服务日志，将满足动作的相关IP利用iptables加入到dorp列表一定时间。所以 使用fail2ban先安装iptables 准备工作Centos7.X 开始,系统自带的防火墙是firewalld,但是也同样支持iptables–关闭firewall： [root@ssh1 ~]# systemctl stop firewalld.service #停止firewall [root@ssh1 ~]# systemctl disable firewalld.service #禁止firewall开机启动 –安装安装iptables防火墙 [root@ssh1 ~]# yum install iptables-services #安装 注：重启iptables服务的话，所有DORP将重置。配置文件位置： [root@ssh1 ~]# ls /etc/sysconfig/iptables /etc/sysconfig/iptables 启动服务 [root@ssh1 ~]# systemctl start iptables.service [root@ssh1 ~]# systemctl enable iptables.service 安装配置1.下载软件包： http://www.fail2ban.org http://www.fail2ban.org/wiki/index.php/Downloads 2.解压查看readme文件 [root@ssh1 ~]# tar xf fail2ban-0.9.4.tar.gz [root@ssh1 fail2ban-0.9.4]# vim README.md #查看以下内容 3.安装： [root@redis fail2ban-0.9.4]# python setup.py install 4.管理文件结构介绍 1）/etc/fail2ban/action.d动作文件夹，内含默认文件。iptables以及mail等动作配置2）/etc/fail2ban/fail2ban.conf定义fail2ban日志级别，日志位置及sock文件位置3）/etc/fail2ban/filter.d条件文件夹，内含默认文件。过滤日志关键内容设置4）/etc/fail2ban/jail.conf主配置文件、模块化。主要设置启用ban动作的服务以及动作阀值。5）/etc/rc.d/init.d/fail2banfail2ban服务的启动脚本 5.生成服务启动脚本： [root@ssh1 ~]# cp fail2ban-0.9.4/files/redhat-initd /etc/rc.d/init.d/fail2ban [root@ssh1 ~]# chkconfig --add fail2ban //开机自启 6.fail2ban配置 /etc/fail2ban/fail2ban.conf [Definition] loglevel = INFO logtarget = SYSLOG syslogsocket = auto socket = /var/run/fail2ban/fail2ban.sock pidfile = /var/run/fail2ban/fail2ban.pid dbfile = /var/lib/fail2ban/fail2ban.sqlite3 dbpurgeage = 86400 注：以上不做任何修改 /etc/fail2ban/jail.conf 邮件发送 ： 注意的是：iptables和sendmail必须对齐，要不然会发生错误； [sshd] #单个服务检查设置，如设置bantime、findtime、maxretry和全局冲突，服务优先级大于全局设置。 enabled = true #是否激活此项（true/false） filter = sshd #过滤规则filter的名字，对应filter.d目录下的sshd.conf action = iptables[name=SSH, port=ssh, protocol=tcp]#动作的相关参数，对应action.d/iptables.conf文件 logpath = /var/log/secure #检测的日志文件path bantime = 3600 findtime = 300 maxretry = 3 防攻击规则参见： # (1)SSH防攻击规则 [ssh-iptables] enabled = true filter = sshd action = iptables[name=SSH, port=ssh, protocol=tcp] sendmail-whois[name=SSH, dest=root, sender=fail2ban@example.com, sendername=&quot;Fail2Ban&quot;] logpath = /var/log/secure maxretry = 5 [ssh-ddos] enabled = true filter = sshd-ddos action = iptables[name=ssh-ddos, port=ssh,sftp protocol=tcp,udp] logpath = /var/log/messages maxretry = 2 [osx-ssh-ipfw] enabled = true filter = sshd action = osx-ipfw logpath = /var/log/secure.log maxretry = 5 [ssh-apf] enabled = true filter = sshd action = apf[name=SSH] logpath = /var/log/secure maxretry = 5 [osx-ssh-afctl] enabled = true filter = sshd action = osx-afctl[bantime=600] logpath = /var/log/secure.log maxretry = 5 [selinux-ssh] enabled = true filter = selinux-ssh action = iptables[name=SELINUX-SSH, port=ssh, protocol=tcp] logpath = /var/log/audit/audit.log maxretry = 5 (2)proftp防攻击规则 [proftpd-iptables] enabled = true filter = proftpd action = iptables[name=ProFTPD, port=ftp, protocol=tcp] sendmail-whois[name=ProFTPD, dest=you@example.com] logpath = /var/log/proftpd/proftpd.log maxretry = 6 (3)邮件防攻击规则 [sasl-iptables] enabled = true filter = postfix-sasl backend = polling action = iptables[name=sasl, port=smtp, protocol=tcp] sendmail-whois[name=sasl, dest=you@example.com] logpath = /var/log/mail.log [dovecot] enabled = true filter = dovecot action = iptables-multiport[name=dovecot, port=&quot;pop3,pop3s,imap,imaps,submission,smtps,sieve&quot;, protocol=tcp] logpath = /var/log/mail.log [dovecot-auth] enabled = true filter = dovecot action = iptables-multiport[name=dovecot-auth, port=&quot;pop3,pop3s,imap,imaps,submission,smtps,sieve&quot;, protocol=tcp] logpath = /var/log/secure [perdition] enabled = true filter = perdition vaction = iptables-multiport[name=perdition,port=&quot;110,143,993,995&quot;] logpath = /var/log/maillog [uwimap-auth] enabled = true filter = uwimap-auth action = iptables-multiport[name=uwimap-auth,port=&quot;110,143,993,995&quot;] logpath = /var/log/maillog (4)apache防攻击规则 [apache-tcpwrapper] enabled = true filter = apache-auth action = hostsdeny logpath = /var/log/httpd/error_log maxretry = 6 [apache-badbots] enabled = true filter = apache-badbots action = iptables-multiport[name=BadBots, port=&quot;http,https&quot;] sendmail-buffered[name=BadBots, lines=5, dest=you@example.com] logpath = /var/log/httpd/access_log bantime = 172800 maxretry = 1 [apache-shorewall] enabled = true filter = apache-noscript action = shorewall sendmail[name=Postfix, dest=you@example.com] logpath = /var/log/httpd/error_log (5)nginx防攻击规则 [nginx-http-auth] enabled = true filter = nginx-http-auth action = iptables-multiport[name=nginx-http-auth,port=&quot;80,443&quot;] logpath = /var/log/nginx/error.log (6)lighttpd防规击规则 [suhosin] enabled = true filter = suhosin action = iptables-multiport[name=suhosin, port=&quot;http,https&quot;] # adapt the following two items as needed logpath = /var/log/lighttpd/error.log maxretry = 2 [lighttpd-auth] enabled = true filter = lighttpd-auth action = iptables-multiport[name=lighttpd-auth, port=&quot;http,https&quot;] # adapt the following two items as needed logpath = /var/log/lighttpd/error.log maxretry = 2 (7)vsftpd防攻击规则 [vsftpd-notification] enabled = true filter = vsftpd action = sendmail-whois[name=VSFTPD, dest=you@example.com] logpath = /var/log/vsftpd.log maxretry = 5 bantime = 1800 [vsftpd-iptables] enabled = true filter = vsftpd action = iptables[name=VSFTPD, port=ftp, protocol=tcp] sendmail-whois[name=VSFTPD, dest=you@example.com] logpath = /var/log/vsftpd.log maxretry = 5 bantime = 1800 (8)pure-ftpd防攻击规则 [pure-ftpd] enabled = true filter = pure-ftpd action = iptables[name=pure-ftpd, port=ftp, protocol=tcp] logpath = /var/log/pureftpd.log maxretry = 2 bantime = 86400 (9)mysql防攻击规则 [mysqld-iptables] enabled = true filter = mysqld-auth action = iptables[name=mysql, port=3306, protocol=tcp] sendmail-whois[name=MySQL, dest=root, sender=fail2ban@example.com] logpath = /var/log/mysqld.log maxretry = 5 (10)apache phpmyadmin防攻击规则 [apache-phpmyadmin] enabled = true filter = apache-phpmyadmin action = iptables[name=phpmyadmin, port=http,https protocol=tcp] logpath = /var/log/httpd/error_log maxretry = 3 # /etc/fail2ban/filter.d/apache-phpmyadmin.conf 将以下内容粘贴到apache-phpmyadmin.conf里保存即可以创建一个apache-phpmyadmin.conf文件. # Fail2Ban configuration file # # Bans bots scanning for non-existing phpMyAdmin installations on your webhost. # # Author: Gina Haeussge # [Definition] docroot = /var/www badadmin = PMA|phpmyadmin|myadmin|mysql|mysqladmin|sqladmin|mypma|admin|xampp|mysqldb|mydb|db|pmadb|phpmyadmin1|phpmyadmin2 # Option: failregex # Notes.: Regexp to match often probed and not available phpmyadmin paths. # Values: TEXT # failregex = [[]client []] File does not exist: %(docroot)s/(?:%(badadmin)s) # Option: ignoreregex # Notes.: regex to ignore. If this regex matches, the line is ignored. # Values: TEXT # ignoreregex = 7.服务启动 [root@ssh1 ~]# systemctl restart fail2ban 注：fail2ban一定后于iptables启动，即重启iptables一定要重启fail2ban，相反重启fail2ban不用重新启iptables。 8.查询限制列表 红色表示由fail2ban限制 [root@ssh1 ~]# iptables -L --line-numbers 9.解除fail2ban绑定的IP [root@ssh1 ~]# iptables -D f2b-ssh 1 解除第一个拒绝的IP 10 . 统计登陆失败的IP [root@ssh1 ~]# find /var/log -name &apos;secure*&apos; -type f | while read line;do awk &apos;/Failed/{print $(NF-3)}&apos; $line;done | awk &apos;{a[$0]++}END{for (j in a) if(a[j] &gt; 20) print j&quot;=&quot;a[j]}&apos; | sort -n -t&apos;=&apos; -k 2 10.10.11.19=67 202.99.172.155=24 222.178.229.67=1005 fail2ban状态监控脚本因为重启iptables需要重启fai2ban服务，故而我们需要增加此监控脚本防止管理员疏忽。1）增加脚本文件夹 mkdir ~/script 2）vim编辑~/script/f2bAutoRestart.sh加入如下内容 #!/bin/bash fl=$(iptables -L -v -n | grep &apos;Chain f&apos; | wc -l)#echo $flif [ $fl -eq 0 ]; then echo &apos;restart fai2band&apos; /etc/init.d/fail2ban restart fi 3)添加计划任务 crontab -e 添加如下内容： */5 * * * * sh ~/script/f2bAutoRestart.sh]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[first]]></title>
    <url>%2F2018%2F11%2F08%2Ffirst%2F</url>
    <content type="text"><![CDATA[Hibernate框架的概述 1. Hibernate框架的概述 * Hibernate称为 * Hibernate是一个开放源代码的对象关系映射（ORM）框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 * Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用。 * Hibernate是轻量级JavaEE应用的持久层解决方案，是一个关系数据库ORM框架 2. 记住：Hibernate是一个持久层的ORM框架！！！ 什么是ORM（对象关系映射） 1. ORM映射：Object Relational Mapping * O：面向对象领域的Object（JavaBean对象） * R：关系数据库领域的Relational（表的结构） * M：映射Mapping（XML的配置文件） 2. 简单一句话：Hibernate使程序员通过操作对象的方式来操作数据库表记录 Hibernate优点 1. 优点 * Hibernate对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码 * Hibernate是一个基于jdbc的主流持久化框架，是一个优秀的orm实现，它很大程度的简化了dao层编码工作 * Hibernate的性能非常好，因为它是一个轻量级框架。映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系 技术分析之Hibernate框架的快速入门 第一步：下载Hibernate5的运行环境 1. 下载相应的jar包等 * http://sourceforge.net/projects/hibernate/files/hibernate-orm/5.0.7.Final/hibernate-release-5.0.7.Final.zip/download 2. 解压后对目录结构有一定的了解 第二步：创建表结构 1. 建表语句如下 Create database hibernate_day01; Use hibernate_day01; CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT &apos;客户编号(主键)&apos;, `cust_name` varchar(32) NOT NULL COMMENT &apos;客户名称(公司名称)&apos;, `cust_user_id` bigint(32) DEFAULT NULL COMMENT &apos;负责人id&apos;, `cust_create_id` bigint(32) DEFAULT NULL COMMENT &apos;创建人id&apos;, `cust_source` varchar(32) DEFAULT NULL COMMENT &apos;客户信息来源&apos;, `cust_industry` varchar(32) DEFAULT NULL COMMENT &apos;客户所属行业&apos;, `cust_level` varchar(32) DEFAULT NULL COMMENT &apos;客户级别&apos;, `cust_linkman` varchar(64) DEFAULT NULL COMMENT &apos;联系人&apos;, `cust_phone` varchar(64) DEFAULT NULL COMMENT &apos;固定电话&apos;, `cust_mobile` varchar(16) DEFAULT NULL COMMENT &apos;移动电话&apos;, PRIMARY KEY (`cust_id`) ) ENGINE=InnoDB AUTO_INCREMENT=94 DEFAULT CHARSET=utf8; 第三步：搭建Hibernate的开发环境 1. 创建WEB工程，引入Hibernate开发所需要的jar包 * MySQL的驱动jar包 * Hibernate开发需要的jar包（资料/hibernate-release-5.0.7.Final/lib/required/所有jar包） * 日志jar包（资料/jar包/log4j/所有jar包） 第四步：编写JavaBean实体类 1. Customer类的代码如下： public class Customer { private Long cust_id; private String cust_name; private Long cust_user_id; private Long cust_create_id; private String cust_source; private String cust_industry; private String cust_level; private String cust_linkman; private String cust_phone; private String cust_mobile; // 省略get和set方法 } 第五步：创建类与表结构的映射 1. 在JavaBean所在的包下创建映射的配置文件 * 默认的命名规则为：实体类名.hbm.xml * 在xml配置文件中引入约束（引入的是hibernate3.0的dtd约束，不要引入4的约束） &lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; 2. 如果不能上网，编写配置文件是没有提示的，需要自己来配置 * 先复制http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd --&gt; window --&gt; preferences --&gt; 搜索xml --&gt; 选择xml catalog --&gt; 点击add --&gt; 现在URI --&gt; 粘贴复制的地址 --&gt; 选择location，选择本地的DTD的路径 3. 编写映射的配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; &lt;hibernate-mapping&gt; &lt;class name=&quot;com.itheima.domain.Customer&quot; table=&quot;cst_customer&quot;&gt; &lt;id name=&quot;cust_id&quot; column=&quot;cust_id&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;cust_name&quot; column=&quot;cust_name&quot;/&gt; &lt;property name=&quot;cust_user_id&quot; column=&quot;cust_user_id&quot;/&gt; &lt;property name=&quot;cust_create_id&quot; column=&quot;cust_create_id&quot;/&gt; &lt;property name=&quot;cust_source&quot; column=&quot;cust_source&quot;/&gt; &lt;property name=&quot;cust_industry&quot; column=&quot;cust_industry&quot;/&gt; &lt;property name=&quot;cust_level&quot; column=&quot;cust_level&quot;/&gt; &lt;property name=&quot;cust_linkman&quot; column=&quot;cust_linkman&quot;/&gt; &lt;property name=&quot;cust_phone&quot; column=&quot;cust_phone&quot;/&gt; &lt;property name=&quot;cust_mobile&quot; column=&quot;cust_mobile&quot;/&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 第六步：编写Hibernate核心的配置文件 1. 在src目录下，创建名称为hibernate.cfg.xml的配置文件 2. 在XML中引入DTD约束 &lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt; 3. 打开：资料/hibernate-release-5.0.7.Final/project/etc/hibernate.properties，可以查看具体的配置信息 * 必须配置的4大参数 #hibernate.connection.driver_class com.mysql.jdbc.Driver #hibernate.connection.url jdbc:mysql:///test #hibernate.connection.username gavin #hibernate.connection.password * 数据库的方言（必须配置的） #hibernate.dialect org.hibernate.dialect.MySQLDialect * 可选的配置 #hibernate.show_sql true #hibernate.format_sql true #hibernate.hbm2ddl.auto update * 引入映射配置文件（一定要注意，要引入映射文件，框架需要加载映射文件） * &lt;mapping resource=&quot;com/itheima/domain/Customer.hbm.xml&quot;/&gt; 4. 具体的配置如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:///hibernate_day01&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;mapping resource=&quot;com/itheima/domain/Customer.hbm.xml&quot;/&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; 第七步：编写Hibernate入门代码 1. 具体的代码如下 /** * 测试保存客户 */ @Test public void testSave(){ // 先加载配置文件 Configuration config = new Configuration(); // 默认加载src目录下的配置文件 config.configure(); // 创建SessionFactory对象 SessionFactory factory = config.buildSessionFactory(); // 创建session对象 Session session = factory.openSession(); // 开启事务 Transaction tr = session.beginTransaction(); // 编写保存代码 Customer c = new Customer(); // c.setCust_id(cust_id); 已经自动递增 c.setCust_name(&quot;测试名称&quot;); c.setCust_mobile(&quot;110&quot;); // 保存客户 session.save(c); // 提交事务 tr.commit(); // 释放资源 session.close(); factory.close(); } 回忆：快速入门 1. 下载Hibernate框架的开发包 2. 编写数据库和表结构 3. 创建WEB的项目，导入了开发的jar包 * MySQL驱动包、Hibernate开发的必须要有的jar包、日志的jar包 4. 编写JavaBean，以后不使用基本数据类型，使用包装类 5. 编写映射的配置文件（核心），先导入开发的约束，里面正常配置标签 6. 编写hibernate的核心的配置文件，里面的内容是固定的 7. 编写代码，使用的类和方法 技术分析之：Hibernate常用的配置文件 Hibernate配置文件之映射配置文件 1. 映射文件，即Stu.hbm.xml的配置文件 * &lt;class&gt;标签 -- 用来将类与数据库表建立映射关系 * name -- 类的全路径 * table -- 表名.(类名与表名一致,那么table属性也可以省略) * catalog -- 数据库的名称，基本上都会省略不写 * &lt;id&gt;标签 -- 用来将类中的属性与表中的主键建立映射，id标签就是用来配置主键的。 * name -- 类中属性名 * column -- 表中的字段名.(如果类中的属性名与表中的字段名一致,那么column可以省略.) * length -- 字段的程度，如果数据库已经创建好了，那么length可以不写。如果没有创建好，生成表结构时，length最好指定。 * &lt;property&gt; -- 用来将类中的普通属性与表中的字段建立映射. * name -- 类中属性名 * column -- 表中的字段名.(如果类中的属性名与表中的字段名一致,那么column可以省略.) * length -- 数据长度 * type -- 数据类型（一般都不需要编写，如果写需要按着规则来编写） * Hibernate的数据类型 type=&quot;string&quot; * Java的数据类型 type=&quot;java.lang.String&quot; * 数据库字段的数据类型 &lt;column name=&quot;name&quot; sql-type=&quot;varchar&quot;/&gt; Hibernate配置文件之核心配置文件 1. 核心配置文件的两种方式 * 第一种方式是属性文件的形式，即properties的配置文件 * hibernate.properties * hibernate.connection.driver_class=com.mysql.jdbc.Driver * 缺点 * 不能加载映射的配置文件，需要手动编写代码去加载 * 第二种方式是XML文件的形式，开发基本都会选择这种方式 * hibernate.cfg.xml * &lt;property name=&quot;hibernate.connection.driver_class&quot; &gt;com.mysql.jdbc.Driver&lt;/property&gt; * 优点 * 格式比较清晰 * 编写有提示 * 可以在该配置文件中加载映射的配置文件（最主要的） 2. 关于hibernate.cfg.xml的配置文件方式 * 必须有的配置 * 数据库连接信息: hibernate.connection.driver_class -- 连接数据库驱动程序 hibernate.connection.url -- 连接数据库URL hibernate.connection.username -- 数据库用户名 hibernate.connection.password -- 数据库密码 * 方言: hibernate.dialect -- 操作数据库方言 * 可选的配置 * hibernate.show_sql -- 显示SQL * hibernate.format_sql -- 格式化SQL * hibernate.hbm2ddl.auto -- 通过映射转成DDL语句 * create -- 每次都会创建一个新的表.---测试的时候 * create-drop -- 每次都会创建一个新的表,当执行结束之后,将创建的这个表删除.---测试的时候 * update -- 如果有表,使用原来的表.没有表,创建一个新的表.同时更新表结构. * validate -- 如果有表,使用原来的表.同时校验映射文件与表中字段是否一致如果不一致就会报错. * 加载映射 * 如果XML方式：&lt;mapping resource=&quot;cn/itcast/hibernate/domain/User.hbm.xml&quot; /&gt; 技术分析之Hibernate常用的接口和类 Configuration类和作用 1. Configuration类 * Configuration对象用于配置并且启动Hibernate。 * Hibernate应用通过该对象来获得对象-关系映射文件中的元数据，以及动态配置Hibernate的属性，然后创建SessionFactory对象。 * 简单一句话：加载Hibernate的配置文件，可以获取SessionFactory对象。 2. Configuration类的其他应用（了解） * 加载配置文件的种类，Hibernate支持xml和properties类型的配置文件，在开发中基本都使用XML配置文件的方式。 * 如果采用的是properties的配置文件，那么通过Configuration configuration = new Configuration();就可以假装配置文件 * 但是需要自己手动加载映射文件 * 例如：config.addResource(&quot;cn/itcast/domain/Student.hbm.xml&quot;); * 如果采用的XML的配置文件，通过Configuration configuration = new Configuration().configure();加载配置文件 SessionFactory：重要 1. 是工厂类，是生成Session对象的工厂类 2. SessionFactory类的特点 * 由Configuration通过加载配置文件创建该对象。 * SessionFactory对象中保存了当前的数据库配置信息和所有映射关系以及预定义的SQL语句。同时，SessionFactory还负责维护Hibernate的二级缓存。 * 预定义SQL语句 * 使用Configuration类创建了SessionFactory对象是，已经在SessionFacotry对象中缓存了一些SQL语句 * 常见的SQL语句是增删改查（通过主键来查询） * 这样做的目的是效率更高 * 一个SessionFactory实例对应一个数据库，应用从该对象中获得Session实例。 * SessionFactory是线程安全的，意味着它的一个实例可以被应用的多个线程共享。 * SessionFactory是重量级的，意味着不能随意创建或销毁它的实例。如果只访问一个数据库，只需要创建一个SessionFactory实例，且在应用初始化的时候完成。 * SessionFactory需要一个较大的缓存，用来存放预定义的SQL语句及实体的映射信息。另外可以配置一个缓存插件，这个插件被称之为Hibernate的二级缓存，被多线程所共享 3. 总结 * 一般应用使用一个SessionFactory,最好是应用启动时就完成初始化。 编写HibernateUtil的工具类 1. 具体代码如下 public class HibernateUtil { private static final Configuration cfg; private static final SessionFactory factory; static{ // 给常量赋值 // 加载配置文件 cfg = new Configuration().configure(); // 生成factory对象 factory = cfg.buildSessionFactory(); } // 获取Session对象 public static Session openSession(){ return factory.openSession(); } } Session接口 1. 概述 * Session是在Hibernate中使用最频繁的接口。也被称之为持久化管理器。它提供了和持久化有关的操作，比如添加、修改、删除、加载和查询实体对象 * Session 是应用程序与数据库之间交互操作的一个单线程对象，是 Hibernate 运作的中心 * Session是线程不安全的 * 所有持久化对象必须在 session 的管理下才可以进行持久化操作 * Session 对象有一个一级缓存，显式执行 flush 之前，所有的持久化操作的数据都缓存在 session 对象处 * 持久化类与 Session 关联起来后就具有了持久化的能力 2. 特点 * 不是线程安全的。应避免多个线程使用同一个Session实例 * Session是轻量级的，它的创建和销毁不会消耗太多的资源。应为每次客户请求分配独立的Session实例 * Session有一个缓存，被称之为Hibernate的一级缓存。每个Session实例都有自己的缓存 3. 常用的方法 * save(obj) * delete(obj) * get(Class,id) * update(obj) * saveOrUpdate(obj) -- 保存或者修改（如果没有数据，保存数据。如果有，修改数据） * createQuery() -- HQL语句的查询的方式 Transaction接口 1. Transaction是事务的接口 2. 常用的方法 * commit() -- 提交事务 * rollback() -- 回滚事务 3. 特点 * Hibernate框架默认情况下事务不自动提交.需要手动提交事务 * 如果没有开启事务，那么每个Session的操作，都相当于一个独立的事务 开发步骤 1. 准备环境 * 在资料/crm/ui/WebRoot下所有的文件，拷贝到工程中 * 引入JSTL的标签库，JSP页面会报错 编写代码]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux优化思维导图]]></title>
    <url>%2F2018%2F05%2F02%2FLinux%E4%BC%98%E5%8C%96%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[这个图是 Linux 性能分析最重要的参考资料之一，它告诉你，在 Linux 不同子系统出现性能问题后，应该用什么样的工具来观测和分析。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
</search>
